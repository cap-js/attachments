const cds = require('@sap/cds')
const LOG = cds.log('malware-scanner')
const crypto = require('crypto');
const { MAX_FILE_SIZE, sizeInBytes } = require('../lib/helper');

class MockedMalwareScanner extends cds.ApplicationService {
  init() {
    this.on('ScanAttachmentsFile', this.scanAttachmentsFile)
    this.on('scan', this.scanFile)

    return super.init()
  }

  /**
     * Scans the "content" property of the given entity, specified by the CSN name (target) and 
     * the keys object, for malware. 
     * Updates the status property on the given entity to reflect if the file is clean.
     * Triggers an attachments service delete event to remove the malware.
     * @param {{data: {target: string, keys: object}}} msg The target is the CSN Entity name, which is used to lookup entity via cds.model.definitions[<target>].
     */
  async scanAttachmentsFile(msg) {
    const { target, keys } = msg.data
    const scanEnabled = cds.env.requires?.attachments?.scan ?? true
    if (!scanEnabled) {
      LOG.warn(`Malware scanner is disabled! Please consider enabling it`)
      return
    }

    LOG.debug(`Initiating malware scan request for ${target}, ${JSON.stringify(keys)} `)

    const AttachmentsSrv = await cds.connect.to("attachments")

    const model = cds.context.model ?? cds.model
    //Make sure its the active target
    const _target = model.definitions[target].actives ?? model.definitions[target]

    if (!_target) {
      LOG.error(`Could not scan ${target}, ${JSON.stringify(keys)} for malware as no CSN entity definition was found for the name!`)
      return
    }

    await this.updateStatus(_target, keys, "Scanning")

    LOG.debug(`Fetching file content for scanning for ${target}, ${JSON.stringify(keys)}`)
    const contentStream = await AttachmentsSrv.get(model.definitions[target], keys)

    if (!contentStream) {
      LOG.warn(`Cannot fetch file content for malware scanning for ${target}, ${JSON.stringify(keys)}! Check if the file exists.`)
      await this.updateStatus(_target, keys, "Failed")
      return
    }

    let res;
    try {
      res = await this.scan(contentStream)
    } catch (err) {
      LOG.error(`Request to malware scanner failed for ${target}, ${JSON.stringify(keys)}`, err)
      await this.updateStatus(target, keys, "Failed")
      throw err;
    }

    const status = res.isMalware ? "Infected" : "Clean"
    const hash = res.hash

    const maxFileSize = _target.elements['content']['@Validation.Maximum'] ? sizeInBytes(_target.elements['content']['@Validation.Maximum'], target) ?? MAX_FILE_SIZE : MAX_FILE_SIZE;
    if (res.scanSize > maxFileSize) {
      LOG.warn(`The attachment size for ${target}, ${JSON.stringify(keys)} is larger then ${maxFileSize} bytes. Deleting the attachmentâ€¦`) 
      await AttachmentsSrv.emit('DeleteAttachment', { target: _target.name, url: (await SELECT.one.from(_target).where(keys).columns('url'))?.url })
      await this.updateStatus(target, Object.assign({ hash }, keys), 'Failed')
      return;
    }

    if (status === "Infected") {
      LOG.warn(`Malware scan completed for ${target}, ${JSON.stringify(keys)} - file is infected. Triggering delete of the file.`)
      //If the scan was triggered on a draft record also delete that one.
      if (_target.drafts?.name === target) {
        await AttachmentsSrv.emit('DeleteInfectedAttachment', { target: _target.drafts.name, keys, hash })
      }
    } else if (status === "Clean") {
      LOG.debug(`Malware scan completed for ${target}, ${JSON.stringify(keys)} - file is clean`)
    }

    //Assign hash as another condition to ensure the correct file is marked as fine
    await this.updateStatus(target, Object.assign({ hash }, keys), status)
  }

  /**
   * Mocks scanning the file. Always returns true!
   * @param {*} req.data.file 
   */
  async scanFile(req) {
    const { file } = req.data;

    LOG.info(`Setting scan status to Clean (development mode)!`)

    let fileSize = 0;
    const hash = crypto.createHash('sha256');

    if (file) {
      for await (const chunk of file) {
        fileSize += chunk.length;
        hash.update(chunk);
      }
    }

    const sha256Hash = hash.digest('hex');
    file?.destroy();

    return {
      isMalware: false,
      encryptedContentDetected: false,
      scanSize: fileSize,
      finding: undefined,
      mimeType: 'empty',
      hash: sha256Hash,
    };
  }

  async updateStatus(_target, keys, status) {
    if (_target.drafts) {
      await Promise.all([
        UPDATE.entity(_target).where(keys).set({ status }),
        UPDATE.entity(_target.drafts).where(keys).set({ status })
      ])
    } else {
      await UPDATE.entity(_target).where(keys).set({ status })
    }
  }
}

module.exports = MockedMalwareScanner
