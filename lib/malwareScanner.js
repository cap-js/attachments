const cds = require('@sap/cds')
const https = require('https')
const crypto = require("crypto")
const { URL } = require('url')
const LOG = cds.log('malware-scanner')

class MalwareScanner extends cds.Service {

  init() {
    this.credentials = getCredentials()
    this.on('ScanFile', this.scan)
  }

  /**
   * Scans the "content" property of the given entity, specified by the CSN name (target) and 
   * the keys object, for malware. 
   * Updates the status property on the given entity to reflect if the file is clean.
   * Triggers an attachments service delete event to remove the malware.
   * @param {{data: {target: string, keys: object}}} msg The target is the CSN Entity name, which is used to lookup entity via cds.model.definitions[<target>].
   */
  async scan(msg) {
    const { target, keys } = msg.data
    const scanEnabled = cds.env.requires?.attachments?.scan ?? true
    if (!scanEnabled) {
      LOG.warn(`Malware scanner is disabled! Please consider enabling it`)
    }

    LOG.debug(`Initiating malware scan request for ${target}, ${keys} `)

    const AttachmentsSrv = await cds.connect.to("attachments")

    const model = cds.context.model ?? cds.model
    //Make sure its the active target
    const _target = model.definitions[target].actives ?? model.definitions[target]

    if (!_target) {
      LOG.error(`Could not scan ${target}, ${keys} for malware as no CSN entity definition was found for the name!`)
      return
    }

    await this.updateStatus(_target, keys, "Scanning")

    LOG.debug(`Fetching file content for scanning for ${target}, ${keys}`)
    const contentStream = await AttachmentsSrv.get(model.definitions[target], keys)

    if (!contentStream) {
      LOG.warn(`Cannot fetch file content for malware scanning for ${target}, ${keys}! Check if the file exists.`)
      await this.updateStatus(_target, keys, "Failed")
      return
    }

    let response
    const scanStartTime = Date.now()

    try {
      LOG.warn(`Preparing authentication for malware scanning service for ${target}, ${keys}`)

      // Prepare request options
      const url = new URL(`https://${this.credentials.uri}/scan`)
      const requestOptions = {
        method: 'POST',
        hostname: url.hostname,
        port: url.port || 443,
        path: url.pathname,
        headers: {}
      }

      if (this.credentials?.certificate && this.credentials?.key) {
        const cert = new crypto.X509Certificate(this.credentials.certificate)
        const expiryDate = new Date(cert.validTo)
        const now = Date.now()

        // Show warning if certificate is expired or expiring within 30 days
        const msIn30Days = 30 * 24 * 60 * 60 * 1000

        if (expiryDate.getTime() < now) {
          LOG.error('Malware scanner certificate expired', { fileId: keys.ID, validTo: cert.validTo })
          throw new Error('Malware scanner certificate expired')
        } else if (expiryDate.getTime() - now < msIn30Days) {
          LOG.warn('Malware scanner certificate expiring soon', { fileId: keys.ID, validTo: cert.validTo })
        }

        // mTLS: set HTTPS agent
        requestOptions.cert = this.credentials.certificate
        requestOptions.key = this.credentials.key
        requestOptions.rejectUnauthorized = false

        LOG.debug('Using mTLS authorization', { fileId: keys.ID })
      } else if (this.credentials?.username && this.credentials?.password) {
        // Basic Auth: set Authorization header
        LOG.warn(
          'Deprecated: Basic Authentication for malware scanning is deprecated and will be removed in future releases.',
          { fileId: keys.ID }
        )
        requestOptions.headers.Authorization =
            "Basic " + Buffer.from(`${this.credentials.username}:${this.credentials.password}`, "binary").toString("base64")
        LOG.debug('Using basic authorization', { fileId: keys.ID })
      } else {
        throw new Error("Could not find any credentials to authenticate against malware scanning service, please make sure binding and service key exists.")
      }

      // Use https.request instead of fetch for proper mTLS support
      response = await new Promise((resolve, reject) => {
        const req = https.request(requestOptions, (res) => {
          let data = ''
          res.on('data', chunk => data += chunk)
          res.on('end', () => {
            resolve({
              status: res.statusCode,
              statusText: res.statusMessage,
              ok: res.statusCode >= 200 && res.statusCode < 300,
              data: data
            })
          })
        })

        req.on('error', reject)

        // Stream the file content to the request
        contentStream.pipe(req)
      })

      if (!response.ok) {
        const json = JSON.parse(response.data || '{}')
        const errorMsg = JSON.stringify(json) || response.statusText || 'Unknown error from malware scanner'
        throw new Error(`Malware scanner responded with status ${response.status}: ${errorMsg}`)
      }

    } catch (error) {
      const scanDuration = Date.now() - scanStartTime
      LOG.error(`Request to malware scanner failed for ${target}, ${keys}`, error,
        'Check malware scanner service binding and network connectivity',
        { scanDuration, scannerUri: this.credentials?.uri }
      )
      await this.updateStatus(target, keys, "Failed")
      contentStream?.destroy()
      return
    } finally {
      contentStream?.destroy()
    }

    const responseText = JSON.parse(response.data)
    const scanDuration = Date.now() - scanStartTime
    LOG.debug(`Malware scan response for ${target}, ${keys}`, { scanDuration, response: responseText })

    const status = responseText.malwareDetected ? "Infected" : "Clean"
    const hash = responseText.SHA256

    if (status === "Infected") {
      LOG.warn(`Malware scan completed for ${target}, ${keys} - file is infected. Triggering delete of the file.`)
      await AttachmentsSrv.emit('DeleteInfectedAttachment', { target: _target.name, keys, hash })
      //If the scan was triggered on a draft record also delete that one.
      if (_target.drafts?.name === target) {
        await AttachmentsSrv.emit('DeleteInfectedAttachment', { target: _target.drafts.name, keys, hash })
      }
    } else if (status === "Clean") {
      LOG.debug(`Malware scan completed for ${target}, ${keys} - file is clean`)
    }

    //Assign hash as another condition to ensure the correct file is marked as fine
    await this.updateStatus(target, Object.assign({ hash }, keys), status)
  }

  async updateStatus(_target, keys, status) {
    if (_target.drafts) {
      await Promise.all([
        UPDATE.entity(_target).where(keys).set({ status }),
        UPDATE.entity(_target.drafts).where(keys).set({ status })
      ])
    } else {
      await UPDATE.entity(_target).where(keys).set({ status })
    }
  }
}

module.exports = MalwareScanner

function getCredentials() {
  const credentials = cds.env.requires?.malwareScanner?.credentials
  if (!credentials) {
    throw new Error(`cds.env.requires.malwareScanner.credentials is empty! Please bind the SAP Malware Scanning service against your app!`)
  }
  const requiredFields = {
    mTLS: ['uri', 'certificate', 'key'],
    basic: ['uri', 'username', 'password']
  }
  const missingMTLS = requiredFields.mTLS.filter(field => !credentials[field])
  const missingBasic = requiredFields.basic.filter(field => !credentials[field])

  if (missingMTLS.length > 0 && missingBasic.length > 0) {
    throw new Error(`Missing Malware Scanner credentials: mTLS [${missingMTLS.join(', ')}], Basic Auth [${missingBasic.join(', ')}]`)
  }
  LOG.debug(`Malware scanning credentials successfully retrieved.`)
  return credentials
}