const cds = require('@sap/cds')
const LOG = cds.log('malware-scanner');

class MalwareScanner extends cds.Service {

  init() {
    this.credentials = getCredentials()
    this.on('ScanFile', this.scan);
  }

  /**
   * Scans the "content" property of the given entity, specified by the CSN name (target) and 
   * the keys object, for malware. 
   * Updates the status property on the given entity to reflect if the file is clean.
   * Triggers an attachments service delete event to remove the malware.
   * @param {{data: {target: string, keys: object}}} msg The target is the CSN Entity name, which is used to lookup entity via cds.model.definitions[<target>].
   */
  async scan(msg) {
    const { target, keys } = msg.data;
    const scanEnabled = cds.env.requires?.attachments?.scan ?? true
    if (!scanEnabled) {
      LOG.warn(`Malware scanner is disabled! Please consider enabling it`)
    }

    LOG.debug(`Initiating malware scan request for ${target}, ${keys} `)

    const AttachmentsSrv = await cds.connect.to("attachments")

    const model = cds.context.model ?? cds.model;
    //Make sure its the active target
    const _target = model.definitions[target].actives ?? model.definitions[target];

    if (!_target) {
      LOG.error(`Could not scan ${target}, ${keys} for malware as no CSN entity definition was found for the name!`)
      return;
    }

    await this.updateStatus(_target, keys, "Scanning")

    LOG.debug(`Fetching file content for scanning for ${target}, ${keys}`)
    const contentStream = await AttachmentsSrv.get(model.definitions[target], keys)

    if (!contentStream) {
      LOG.warn(`Cannot fetch file content for malware scanning for ${target}, ${keys}! Check if the file exists.`)
      await this.updateStatus(_target, keys, "Failed")
      return
    }

    let response
    const scanStartTime = Date.now()

    try {
      // Stream the file directly to the scanner without loading into memory
      response = await fetch(`https://${this.credentials.uri}/scan`, {
        method: "POST",
        headers: {
          Authorization:
            "Basic " + Buffer.from(`${this.credentials.username}:${this.credentials.password}`, "binary").toString("base64"),
        },
        body: contentStream,
        duplex: 'half' // Required for streaming request bodies
      })

    } catch (error) {
      const scanDuration = Date.now() - scanStartTime
      LOG.error(`Request to malware scanner failed for ${target}, ${keys}`, error,
        'Check malware scanner service binding and network connectivity',
        { scanDuration, scannerUri: this.credentials?.uri }
      )
      await this.updateStatus(target, keys, "Failed")
      contentStream?.destroy()
      return
    } finally {
      contentStream?.destroy()
    }

    const responseText = await response.json()
    const scanDuration = Date.now() - scanStartTime
    LOG.debug(`Malware scan response for ${target}, ${keys}`, { scanDuration, response: responseText })

    const status = responseText.malwareDetected ? "Infected" : "Clean"
    const hash = responseText.SHA256

    if (status === "Infected") {
      LOG.warn(`Malware scan completed for ${target}, ${keys} - file is infected. Triggering delete of the file.`);
      await AttachmentsSrv.emit('DeleteInfectedAttachment', { target: _target.name, keys, hash })
      //If the scan was triggered on a draft record also delete that one.
      if (_target.drafts?.name === target) {
        await AttachmentsSrv.emit('DeleteInfectedAttachment', { target: _target.drafts.name, keys, hash })
      }
    } else if (status === "Clean") {
      LOG.debug(`Malware scan completed for ${target}, ${keys} - file is clean`);
    }

    //Assign hash as another condition to ensure the correct file is marked as fine
    await this.updateStatus(target, Object.assign({ hash }, keys), status)
  }

  async updateStatus(_target, keys, status) {
    if (_target.drafts) {
      await Promise.all([
        UPDATE.entity(_target).where(keys).set({ status }),
        UPDATE.entity(_target.drafts).where(keys).set({ status })
      ]);
    } else {
      await UPDATE.entity(_target).where(keys).set({ status })
    }
  }
}

module.exports = MalwareScanner;

function getCredentials() {
  const credentials = cds.env.requires?.malwareScanner?.credentials
  if (!credentials) {
    throw new Error(`cds.env.requires.malwareScanner.credentials is empty! Please bind the SAP Malware Scanning service against your app!`)
  }
  const requiredFields = ['uri', 'username', 'password']
  const missingFields = requiredFields.filter(field => !credentials[field])

  if (missingFields.length > 0) {
    throw new Error(`Missing Malware Scanner credentials: ${missingFields.join(', ')}`)
  }
  LOG.debug(`Malware scanning credentials successfully retrieved.`)
  return credentials
}