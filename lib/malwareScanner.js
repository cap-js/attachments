const cds = require('@sap/cds')
const { SELECT } = cds.ql
const { logConfig } = require('./logger')
const https = require('https')
const crypto = require("crypto")

async function scanRequest(Attachments, key, req) {
  logConfig.processStep('Initiating malware scan request', {
    attachmentEntity: Attachments.name,
    fileId: key.ID
  })

  const scanEnabled = cds.env.requires?.attachments?.scan ?? true
  const AttachmentsSrv = await cds.connect.to("attachments")

  // Validate scan configuration
  logConfig.configValidation('attachments.scan', scanEnabled, true,
    scanEnabled ? 'Malware scanning is enabled' : 'Malware scanning is disabled')

  let draftEntity, activeEntity
  if (Attachments.isDraft) {
    draftEntity = Attachments
    activeEntity = Attachments.actives
  } else {
    activeEntity = Attachments
  }

  logConfig.debug('Determined scan entities', {
    fileId: key.ID,
    isDraft: !!draftEntity,
    activeEntity: activeEntity?.name,
    draftEntity: draftEntity?.name
  })

  let currEntity = draftEntity == undefined ? activeEntity : draftEntity

  if (!scanEnabled) {
    const isDevOrTest = cds.env.profiles.some(p => p === "development" || p === "test")
    const isHybrid = cds.env.profiles.includes("hybrid")

    logConfig.info('Malware scanning disabled', {
      fileId: key.ID,
      profiles: cds.env.profiles,
      isDevOrTest,
      isHybrid
    })

    if (isDevOrTest && !isHybrid) {
      logConfig.debug('Setting temporary scanning status in development mode', { fileId: key.ID })
      await updateStatus(AttachmentsSrv, key, "Scanning", currEntity, draftEntity, activeEntity)

      setTimeout(() => {
        logConfig.info('Setting scan status to Clean (development mode)', { fileId: key.ID })
        updateStatus(AttachmentsSrv, key, "Clean", currEntity, draftEntity, activeEntity)
          .catch(e => logConfig.error('Failed to update scan status', e, { fileId: key.ID }))
      }, 1000).unref()
      return
    } else {
      logConfig.debug('Skipping scan - not in development/test mode', {
        fileId: key.ID,
        profiles: cds.env.profiles
      })
      return
    }
  }

  logConfig.debug('Malware scanning enabled - proceeding with scan', { fileId: key.ID })
  await updateStatus(AttachmentsSrv, key, "Scanning", currEntity, draftEntity, activeEntity)

  let credentials
  try {
    credentials = getCredentials()
  } catch (error) {
    logConfig.withSuggestion('error',
      'Malware scanner credentials not available', error,
      'Bind a Malware Scanner service instance to your application',
      { fileId: key.ID })
    await updateStatus(AttachmentsSrv, key, "Failed", currEntity, draftEntity, activeEntity)
    throw error
  }

  logConfig.debug('Fetching file content for scanning', { fileId: key.ID })
  const contentStream = await AttachmentsSrv.get(currEntity, key)

  if (!contentStream) {
    logConfig.withSuggestion('error',
      'Cannot fetch file content for malware scanning', null,
      'Check file exists and storage accessibility',
      { fileId: key.ID })
    await updateStatus(AttachmentsSrv, key, "Failed", currEntity, draftEntity, activeEntity)
    return
  }

  let response
  const scanStartTime = Date.now()

  try {
    logConfig.debug('Streaming file to Malware Scanning Service', {
      fileId: key.ID,
      scannerUri: credentials.uri
    })

    // Stream the file directly to the scanner without loading into memory
    const fetchOptions = {
      method: "POST",
      body: contentStream,
      duplex: 'half' // Required for streaming request bodies
    }

    if (credentials?.certificate && credentials?.key) {
      const cert = new crypto.X509Certificate(credentials.certificate)
      const expiryDate = new Date(cert.validTo)
      const now = new Date()

      if (expiryDate < now) {
        logConfig.error(
          'Malware scanner certificate has expired. Please obtain a new certificate.',
          { fileId: key.ID, validTo: cert.validTo }
        )
        throw new Error('Malware scanner certificate has expired. Please obtain a new certificate.')
      }

      // mTLS: set HTTPS agent
      fetchOptions.agent = new https.Agent({
        cert: credentials.certificate,
        key: credentials.key,
        rejectUnauthorized: true
      })
      logConfig.debug('Using mTLS authorization', { fileId: key.ID })
    } else if (credentials?.username && credentials?.password) {
      // Basic Auth: set Authorization header
      logConfig.warn(
        'Deprecated: Basic Authentication for malware scanning is deprecated and will be removed in future releases.',
        { fileId: key.ID }
      )
      fetchOptions.headers = {
        Authorization:
          "Basic " + Buffer.from(`${credentials.username}:${credentials.password}`, "binary").toString("base64"),
      }
      logConfig.debug('Using basic authorization', { fileId: key.ID })
    } else {
      throw new Error("Could not find any credentials to authenticate against malware scanning service, please make sure binding and service key exists.")
    }
    
    response = await fetch(`https://${credentials.uri}/scan`, fetchOptions)

  } catch (error) {
    const scanDuration = Date.now() - scanStartTime
    logConfig.withSuggestion('error',
      'Request to malware scanner failed', error,
      'Check malware scanner service binding and network connectivity',
      { fileId: key.ID, scanDuration, scannerUri: credentials?.uri })
    await updateStatus(AttachmentsSrv, key, "Failed", currEntity, draftEntity, activeEntity)

    // Cleanup: destroy stream on error
    contentStream?.destroy()
    return
  } finally {
    // Cleanup: destroy stream after request completion
    contentStream?.destroy()
  }

  try {
    const responseText = await response.json()
    const status = responseText.malwareDetected ? "Infected" : "Clean"
    const scanDuration = Date.now() - scanStartTime

    logConfig.debug('Malware scan response processed', { fileId: key.ID, status, scanDuration, malwareDetected: responseText.malwareDetected })

    if (status === "Infected") {
      logConfig.warn('Malware scan detected threat - file removed', {
        fileId: key.ID,
        entity: currEntity.name
      })
      await AttachmentsSrv.deleteInfectedAttachment(currEntity, key, req)
    } else if (status === "Clean") {
      logConfig.info('Malware scan completed - file is clean', {
        fileId: key.ID,
        entity: currEntity.name
      })
    }

    await updateStatus(AttachmentsSrv, key, status, currEntity, draftEntity, activeEntity)

  } catch (err) {
    const scanDuration = Date.now() - scanStartTime
    logConfig.withSuggestion('error',
      'Cannot parse malware scanner response', err,
      'Check malware scanner service health and response format',
      { fileId: key.ID, scanDuration, httpStatus: response?.status })
    await updateStatus(AttachmentsSrv, key, "Failed", currEntity, draftEntity, activeEntity)
  } finally {
    contentStream?.destroy()
  }
}

async function updateStatus(AttachmentsSrv, key, status, currEntity, draftEntity, activeEntity) {
  if (currEntity == draftEntity) {
    currEntity = await getCurrentEntity(currEntity, activeEntity, key)
  }
  await AttachmentsSrv.update(currEntity, key, { status: status })
}

async function getCurrentEntity(draftEntity, activeEntity, key) {
  const entryInDraft = await entryExists(draftEntity, key)
  return entryInDraft ? draftEntity : activeEntity
}

async function entryExists(Attachments, key) {
  try {
    const result = await SELECT.from(Attachments, key).columns('url')
    return result !== null && result !== undefined
  } catch {
    return false
  }
}

function getCredentials() {
  try {
    const credentials = cds.env.requires?.malwareScanner?.credentials
    if (!credentials) {
      logConfig.configValidation('malwareScanner.credentials', credentials, false,
        'Bind a Malware Scanner service instance')
      throw new Error("SAP Malware Scanning service is not bound.")
    }

    const requiredFields = [
      ['uri', 'certificate', 'key'],          // mTLS
      ['uri', 'username', 'password']         // Basic Auth
    ]
    const missingMTLS = requiredFields[0].filter(field => !credentials[field])
    const missingBasic = requiredFields[1].filter(field => !credentials[field])

    if (missingMTLS.length > 0 && missingBasic.length > 0) {
      logConfig.configValidation('malwareScanner.credentials', credentials, false,
        `Malware Scanner credentials missing: mTLS [${missingMTLS.join(', ')}], Basic Auth [${missingBasic.join(', ')}]`)
      throw new Error(`Missing Malware Scanner credentials for both mTLS and Basic Auth`)
    }

    logConfig.configValidation('malwareScanner.credentials', credentials, true,
      'Malware Scanner credentials validated successfully')

    return credentials
  } catch (error) {
    logConfig.withSuggestion('error',
      'Failed to get malware scanner credentials', error,
      'Ensure Malware Scanner service is bound with complete credentials',
      { hasConfig: !!cds.env.requires?.malwareScanner })
    throw error
  }
}

module.exports = {
  scanRequest
}
